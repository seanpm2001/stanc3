<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Analysis_and_optimization__Memory_patterns (stanc.Analysis_and_optimization__Memory_patterns)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">stanc</a> &#x00BB; Analysis_and_optimization__Memory_patterns</nav><h1>Module <code>Analysis_and_optimization__Memory_patterns</code></h1></header><dl><dt class="spec value" id="val-matrix_set"><a href="#val-matrix_set" class="anchor"></a><code><span class="keyword">val</span> matrix_set : <span><a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../Middle/Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../Analysis_and_optimization/Dataflow_types/index.html#type-vexpr">Analysis_and_optimization.Dataflow_types.vexpr</a> * <a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>)</span> Core_kernel.Set.Poly.t</span></code></dt><dd><p>Return a Var expression of the name for each type containing an eigen matrix</p></dd></dl><dl><dt class="spec value" id="val-query_var_eigen_names"><a href="#val-query_var_eigen_names" class="anchor"></a><code><span class="keyword">val</span> query_var_eigen_names : <a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>Return a set of all types containing autodiffable Eigen matrices in an expression.</p></dd></dl><dl><dt class="spec value" id="val-is_nonzero_subset"><a href="#val-is_nonzero_subset" class="anchor"></a><code><span class="keyword">val</span> is_nonzero_subset : <span>set:<span><span class="type-var">'a</span> Core_kernel.Set.Poly.t</span></span> <span>&#45;&gt;</span> <span>subset:<span><span class="type-var">'a</span> Core_kernel.Set.Poly.t</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether one set is a nonzero subset of another set.</p></dd></dl><dl><dt class="spec value" id="val-count_single_idx"><a href="#val-count_single_idx" class="anchor"></a><code><span class="keyword">val</span> count_single_idx : int <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/Index/index.html#type-t">Middle.Index.t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Check an Index to count how many times we see a single index.</p><dl><dt>parameter acc</dt><dd><p>An accumulator from previous folds of multiple expressions.</p></dd></dl><dl><dt>parameter idx</dt><dd><p>An Index to match. For Single types this adds 1 to the acc. For Upfrom and MultiIndex types we check the inner expression for a Single index. All and Between cannot be Single cell access and so pass acc along.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_uni_eigen_loop_indexing"><a href="#val-is_uni_eigen_loop_indexing" class="anchor"></a><code><span class="keyword">val</span> is_uni_eigen_loop_indexing : bool <span>&#45;&gt;</span> <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a> <span>&#45;&gt;</span> <span><span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/Index/index.html#type-t">Middle.Index.t</a></span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Find indices on Matrix and Vector types that perform single cell access. Returns true if it finds a vector, row vector, matrix, or matrix with single cell access as well as an array of any of the above that is accessing the inner matrix types cell.</p><dl><dt>parameter ut</dt><dd><p>An UnsizedType to match against.</p></dd></dl><dl><dt>parameter index</dt><dd><p>This list is checked for Single cell access either at the top level or within the <code>Index</code> types of the list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-query_stan_math_mem_pattern_support"><a href="#val-query_stan_math_mem_pattern_support" class="anchor"></a><code><span class="keyword">val</span> query_stan_math_mem_pattern_support : string <span>&#45;&gt;</span> <span><span>(<a href="../Middle/UnsizedType/index.html#type-autodifftype">Middle.UnsizedType.autodifftype</a> * <a href="../Middle/UnsizedType/index.html#type-t">Middle.UnsizedType.t</a>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_fun_soa_supported"><a href="#val-is_fun_soa_supported" class="anchor"></a><code><span class="keyword">val</span> is_fun_soa_supported : string <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-query_initial_demotable_expr"><a href="#val-query_initial_demotable_expr" class="anchor"></a><code><span class="keyword">val</span> query_initial_demotable_expr : bool <span>&#45;&gt;</span> <span>acc:<span>string Core_kernel.Set.Poly.t</span></span> <span>&#45;&gt;</span> <a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>Query to find the initial set of objects that cannot be SoA. This is mostly recursing over expressions, with the exceptions being functions and indexing expressions. For the logic on functions see the docs for <code>query_initial_demotable_funs</code>.</p><dl><dt>parameter in_loop</dt><dd><p>a boolean to signify if the expression exists inside of a loop. If so, the names of matrix and vector like objects will be returned if the matrix or vector is accessed by single cell indexing.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-query_initial_demotable_funs"><a href="#val-query_initial_demotable_funs" class="anchor"></a><code><span class="keyword">val</span> query_initial_demotable_funs : bool <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span><a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../Middle/Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>Query a function to detect if it or any of its used expression's objects or expressions should be demoted to AoS. * The logic here demotes the expressions in a function to AoS if the function's inner expression returns has a meta type containing a matrix and either of : (1) The function is user defined and the UDFs inputs are matrices. (2) The Stan math function cannot support AoS</p><dl><dt>parameter in_loop</dt><dd><p>A boolean to specify the logic of indexing expressions. See <code>query_initial_demotable_expr</code> for an explanation of the logic.</p></dd></dl><dl><dt>parameter kind</dt><dd><p>The function type, for StanLib functions we check if the function supports SoA and for UserDefined functions we always fail and return back all of the names of the objects passed in expressions to the UDF. exprs The expression list passed to the functions.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_any_soa_supported_expr"><a href="#val-is_any_soa_supported_expr" class="anchor"></a><code><span class="keyword">val</span> is_any_soa_supported_expr : <a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether any functions in the right hand side expression of an assignment support SoA. If so then return true, otherwise return false.</p></dd></dl><dl><dt class="spec value" id="val-is_any_soa_supported_fun_expr"><a href="#val-is_any_soa_supported_fun_expr" class="anchor"></a><code><span class="keyword">val</span> is_any_soa_supported_fun_expr : <span><span><a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../Middle/Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return false if the <code>Fun_kind.t</code> does not support <code>SoA</code></p></dd></dl><dl><dt class="spec value" id="val-is_any_ad_real_data_matrix_expr"><a href="#val-is_any_ad_real_data_matrix_expr" class="anchor"></a><code><span class="keyword">val</span> is_any_ad_real_data_matrix_expr : <a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return true if the rhs expression of an assignment contains only combinations of AutoDiffable Reals and Data Matrices</p></dd></dl><dl><dt class="spec value" id="val-is_any_ad_real_data_matrix_expr_fun"><a href="#val-is_any_ad_real_data_matrix_expr_fun" class="anchor"></a><code><span class="keyword">val</span> is_any_ad_real_data_matrix_expr_fun : <span><span><a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../Middle/Expr/Fixed/index.html#type-t">Middle.Expr.Fixed.t</a></span> <a href="../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return true if the expressions in a function call are all combinations of AutoDiffable Reals and Data Matrices</p></dd></dl><dl><dt class="spec value" id="val-query_initial_demotable_stmt"><a href="#val-query_initial_demotable_stmt" class="anchor"></a><code><span class="keyword">val</span> query_initial_demotable_stmt : bool <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a>,Â <a href="../Middle/Stmt/Located/Meta/index.html#type-t">Middle.Stmt.Located.Meta.t</a>)</span> <a href="../Middle/Stmt/Fixed/index.html#type-t">Middle.Stmt.Fixed.t</a></span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>Query to find the initial set of objects in statements that cannot be SoA. This is mostly recursive over expressions and statements, with the exception of functions and Assignments. * For assignments: We demote the LHS variable if any of the following are true: 1. None of the RHS's functions are able to accept SoA matrices and the rhs is not an internal compiler function. 2. A single cell of the LHS is being assigned within a loop. 3. The top level expression on the RHS is a combination of only data matrices and scalar types. Operations on data matrix and scalar values in Stan math will return a AoS matrix. We currently have no way to tell Stan math to return a SoA matrix. * We demote RHS variables if any of the following are true: 1. The LHS variable has previously or through this iteration been marked AoS. * For functions see the documentation for <code>query_initial_demotable_funs</code> for the logic on demotion rules.</p><dl><dt>parameter in_loop</dt><dd><p>A boolean to specify the logic of indexing expressions. See <code>query_initial_demotable_expr</code> for an explanation of the logic.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-query_demotable_stmt"><a href="#val-query_demotable_stmt" class="anchor"></a><code><span class="keyword">val</span> query_demotable_stmt : <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>,Â int)</span> <a href="../Middle/Stmt/Fixed/Pattern/index.html#type-t">Middle.Stmt.Fixed.Pattern.t</a></span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span></code></dt><dd><p>Look through a statement to see whether the objects used in it need to be modified from SoA to AoS. Returns the set of object names that need demoted in a statement, if any. This function looks at Assignment statements, and returns back the set of top level object names given: 1. If the name of the lhs assignee is in the <code>aos_exits</code>, all the names of the expressions with a type containing a matrix are returned. 2. If the names of the rhs objects containing matrix types are in the subset of aos_exits.</p><dl><dt>parameter aos_exits</dt><dd><p>A set of variables that can be demoted.</p></dd></dl><dl><dt>parameter pattern</dt><dd><p>The Stmt pattern to query.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_kind"><a href="#val-modify_kind" class="anchor"></a><code><span class="keyword">val</span> modify_kind : <span>?&#8288;force_demotion:bool</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/Fun_kind/index.html#type-t">Middle.Fun_kind.t</a></span> * <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> list</span></code></dt><dd><p>Modify a function and it's subexpressions from SoA &lt;-&gt; AoS and vice versa. This performs demotion for sub expressions recursively. The top level expression and it's sub expressions are demoted to SoA if 1. The names of the variables in the subexpressions returning objects holding matrices are all in the modifiable set. 2. The function does not support SoA 3. The <code>force</code> argument is <code>true</code></p><dl><dt>parameter force_demotion</dt><dd><p>If true, forces an expression and it's sub-expressions to be AoS.</p></dd></dl><dl><dt>parameter modifiable_set</dt><dd><p>The set of names that are either demotable to AoS or promotable to SoA.</p></dd></dl><dl><dt>parameter kind</dt><dd><p>A <code>Fun_kind.t</code></p></dd></dl><dl><dt>parameter exprs</dt><dd><p>A list of expressions going into the function. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_expr_pattern"><a href="#val-modify_expr_pattern" class="anchor"></a><code><span class="keyword">val</span> modify_expr_pattern : <span>?&#8288;force_demotion:bool</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/Expr/Fixed/Pattern/index.html#type-t">Middle.Expr.Fixed.Pattern.t</a></span> <span>&#45;&gt;</span> <span><a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <a href="../Middle/Expr/Fixed/Pattern/index.html#type-t">Middle.Expr.Fixed.Pattern.t</a></span></code></dt><dd><p>Modify an expression and it's subexpressions from SoA &lt;-&gt; AoS and vice versa. The only real paths in the below is on the functions and ternary expressions. * The logic for functions is defined in <code>modify_kind</code>. <code>TernaryIf</code> is forcefully demoted to AoS if the type of the expression contains a matrix.</p><dl><dt>parameter force_demotion</dt><dd><p>If true, forces an expression and it's sub-expressions to be AoS.</p></dd></dl><dl><dt>parameter modifiable_set</dt><dd><p>The name of the variables whose associated expressions we want to modify.</p></dd></dl><dl><dt>parameter pattern</dt><dd><p>The expression to modify.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_expr"><a href="#val-modify_expr" class="anchor"></a><code><span class="keyword">val</span> modify_expr : <span>?&#8288;force_demotion:bool</span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a> <span>&#45;&gt;</span> <a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a></code></dt><dd><p>Given a Set of strings containing the names of objects that can be modified from AoS &lt;-&gt; SoA and vice versa, modify them within the expression.</p><dl><dt>parameter mem_pattern</dt><dd><p>The memory pattern to change expressions to.</p></dd></dl><dl><dt>parameter modifiable_set</dt><dd><p>The name of the variables whose associated expressions we want to modify.</p></dd></dl><dl><dt>parameter expr</dt><dd><p>the expression to modify.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_stmt_pattern"><a href="#val-modify_stmt_pattern" class="anchor"></a><code><span class="keyword">val</span> modify_stmt_pattern : <span><span>(<a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>,Â <a href="../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a>)</span> <a href="../Middle/Stmt/Fixed/Pattern/index.html#type-t">Middle.Stmt.Fixed.Pattern.t</a></span> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../Middle/Expr/Typed/index.html#type-t">Middle.Expr.Typed.t</a>,Â <a href="../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a>)</span> <a href="../Middle/Stmt/Fixed/Pattern/index.html#type-t">Middle.Stmt.Fixed.Pattern.t</a></span></code></dt><dd><p>Modify statement patterns in the MIR from AoS &lt;-&gt; SoA and vice versa For <code>Decl</code> and <code>Assignment</code>'s reading in parameters, we demote to AoS if the <code>decl_id</code> (or assign name) is in the modifiable set and otherwise promote the statement to <code>SoA</code>. For general <code>Assignment</code> statements, we check if the assignee is in the demotable set. If so, we force demotion of all of the rhs expressions. All other statements recurse over their statements and expressions. *</p><dl><dt>parameter pattern</dt><dd><p>The statement pattern to modify</p></dd></dl><dl><dt>parameter modifiable_set</dt><dd><p>The name of the variable we are searching for.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_stmt"><a href="#val-modify_stmt" class="anchor"></a><code><span class="keyword">val</span> modify_stmt : <a href="../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a> <span>&#45;&gt;</span> <span>string Core_kernel.Set.Poly.t</span> <span>&#45;&gt;</span> <a href="../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a></code></dt><dd><p>Modify statement patterns in the MIR from AoS &lt;-&gt; SoA and vice versa</p><dl><dt>parameter mem_pattern</dt><dd><p>A mem_pattern to modify expressions to. For the given memory pattern, this modifies statement patterns and expressions to it.</p></dd></dl><dl><dt>parameter stmt</dt><dd><p>The statement to modify.</p></dd></dl><dl><dt>parameter modifiable_set</dt><dd><p>The name of the variable we are searching for.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-collect_mem_pattern_variables"><a href="#val-collect_mem_pattern_variables" class="anchor"></a><code><span class="keyword">val</span> collect_mem_pattern_variables : <span><a href="../Middle/Stmt/Located/index.html#type-t">Middle.Stmt.Located.t</a> Core_kernel.List.t</span> <span>&#45;&gt;</span> <span><span>(string * <span><span><a href="../Middle/Expr/Typed/Meta/index.html#type-t">Middle.Expr.Typed.Meta.t</a> <a href="../Middle__Expr/Fixed/index.html#type-t">Middle.Stmt.Fixed.First.t</a></span> <a href="../Middle/SizedType/index.html#type-t">Middle.SizedType.t</a></span>)</span> list</span></code></dt><dt class="spec value" id="val-pp_mem_patterns"><a href="#val-pp_mem_patterns" class="anchor"></a><code><span class="keyword">val</span> pp_mem_patterns : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="../Middle/Program/Typed/index.html#type-t">Middle.Program.Typed.t</a> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>